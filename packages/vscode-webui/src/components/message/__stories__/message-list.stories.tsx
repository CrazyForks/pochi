import type { Meta, StoryObj } from "@storybook/react";
import type { UIMessage } from "ai";
import logo from "../../../../../vscode/assets/icons/logo128.png";
import { MessageList } from "../message-list";

const meta: Meta<typeof MessageList> = {
  title: "Pochi/Messages",
  component: MessageList,
};

export default meta;
type Story = StoryObj<typeof meta>;

const messages1: UIMessage[] = [
  {
    id: "phtMaNplr0NDM3wE",
    role: "user",
    parts: [
      {
        text: "<file>clients/vscode/src/inline-edit</file> explain this file",
        type: "text",
      },
    ],
    content: "",
    createdAt: new Date("2025-05-18T05:20:30.873Z"),
  },
  {
    id: "msg-oygCkahff8a3ESnpNisn31yJ",
    role: "assistant",
    parts: [
      {
        type: "step-start",
      },
      {
        text: '\n\nI need to check if "inline-edit" is a directory or a file. Let me explore it further.',
        type: "text",
      },
      {
        type: "reasoning",
        reasoning:
          "#### Reasoning\n\nI need to check if the path is a directory or a file.",
        details: [],
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/inline-edit",
          },
          step: 0,
          state: "result",
          result: {
            files: [
              "clients/vscode/src/inline-edit/index.ts",
              "clients/vscode/src/inline-edit/quickPick.ts",
              "clients/vscode/src/inline-edit/util.test.ts",
              "clients/vscode/src/inline-edit/util.ts",
            ],
            isTruncated: false,
          },
          toolName: "listFiles",
          toolCallId: "tooluse_5W72UxuNR0yPCSAA8LhH5Q",
        },
      },
      {
        type: "step-start",
      },
      {
        text: "Now I'll examine the files in the inline-edit directory to understand their purpose.",
        type: "text",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/inline-edit/index.ts",
          },
          step: 1,
          state: "result",
          result: {
            content:
              'import type { Location } from "vscode-languageclient";\nimport { window, TextEditor, Selection, Position, CancellationToken, Range } from "vscode";\nimport { Client } from "../lsp/client";\nimport { Config } from "../Config";\nimport { ContextVariables } from "../ContextVariables";\nimport { getLogger } from "../logger";\nimport { InlineEditCommand, UserCommandQuickpick } from "./quickPick";\n\nexport class InlineEditController {\n  private readonly logger = getLogger("InlineEditController");\n  private readonly editLocation: Location;\n\n  constructor(\n    private client: Client,\n    private config: Config,\n    private contextVariables: ContextVariables,\n    private editor: TextEditor,\n    private range: Range,\n  ) {\n    this.editLocation = {\n      uri: this.editor.document.uri.toString(),\n      range: {\n        start: { line: this.range.start.line, character: 0 },\n        end: {\n          line: this.range.end.character === 0 ? this.range.end.line : this.range.end.line + 1,\n          character: 0,\n        },\n      },\n    };\n  }\n\n  async start(userCommand: string | undefined, cancellationToken: CancellationToken) {\n    const inlineEditCommand: InlineEditCommand | undefined = userCommand\n      ? { command: userCommand }\n      : await this.showQuickPick();\n    if (inlineEditCommand?.command) {\n      await this.provideEditWithCommand(inlineEditCommand, cancellationToken);\n    }\n  }\n\n  private async showQuickPick(): Promise<InlineEditCommand | undefined> {\n    const quickPick = new UserCommandQuickpick(this.client, this.config, this.editLocation);\n    return await quickPick.start();\n  }\n\n  private async provideEditWithCommand(command: InlineEditCommand, cancellationToken: CancellationToken) {\n    // Lock the cursor (editor selection) at start position, it will be unlocked after the edit is done\n    const startPosition = new Position(this.range.start.line, 0);\n    const resetEditorSelection = () => {\n      this.editor.selection = new Selection(startPosition, startPosition);\n    };\n    const selectionListenerDisposable = window.onDidChangeTextEditorSelection((event) => {\n      if (event.textEditor === this.editor) {\n        resetEditorSelection();\n      }\n    });\n    resetEditorSelection();\n\n    this.contextVariables.chatEditInProgress = true;\n    this.logger.log(`Provide edit with command: ${JSON.stringify(command)}`);\n    try {\n      await this.client.chat.provideEdit(\n        {\n          location: this.editLocation,\n          command: command.command,\n          context: command.context,\n          format: "previewChanges",\n        },\n        cancellationToken,\n      );\n    } catch (error) {\n      if (typeof error === "object" && error && "message" in error && typeof error["message"] === "string") {\n        if (cancellationToken.isCancellationRequested || error["message"].includes("This operation was aborted")) {\n          // user canceled\n        } else {\n          window.showErrorMessage(error["message"]);\n        }\n      }\n    }\n    selectionListenerDisposable.dispose();\n    this.contextVariables.chatEditInProgress = false;\n  }\n}\n',
            isTruncated: false,
          },
          toolName: "readFile",
          toolCallId: "toolu_vrtx_01Rj4WXEVvqUsrFcbxoF5cGV",
        },
      },
      {
        type: "step-start",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/inline-edit/quickPick.ts",
          },
          step: 2,
          state: "result",
          result: {
            content:
              'import {\n  CancellationTokenSource,\n  QuickInputButton,\n  QuickInputButtons,\n  QuickPickItem,\n  QuickPickItemButtonEvent,\n  QuickPickItemKind,\n  Range,\n  ThemeIcon,\n  window,\n  workspace,\n} from "vscode";\nimport path from "path";\nimport { ChatEditCommand, ChatEditFileContext } from "tabby-agent";\nimport { listSymbols } from "../findSymbols";\nimport { Config } from "../Config";\nimport { Deferred } from "../deferred";\nimport { Client } from "../lsp/client";\nimport { Location } from "vscode-languageclient";\nimport { listFiles } from "../findFiles";\nimport { wrapCancelableFunction } from "../cancelableFunction";\nimport { InlineEditParseResult, parseUserCommand, replaceLastOccurrence } from "./util";\n\nexport interface InlineEditCommand {\n  command: string;\n  context?: ChatEditFileContext[];\n}\n\ninterface CommandQuickPickItem extends QuickPickItem {\n  value: string;\n}\n\n/**\n * Helper method to get file items with consistent formatting\n * This is used by both context picker and file selection picker\n */\nconst wrappedListFiles = wrapCancelableFunction(\n  listFiles,\n  (args) => args[2],\n  (args, token) => {\n    args[2] = token;\n    return args;\n  },\n);\n\nconst getFileItems = async (query: string, maxResults: number): Promise<FileSelectionQuickPickItem[]> => {\n  const fileList = await wrappedListFiles(query, maxResults);\n  const fileItems: FileSelectionQuickPickItem[] = fileList.map((fileItem) => {\n    const relativePath = workspace.asRelativePath(fileItem.uri);\n    const basename = path.basename(fileItem.uri.fsPath);\n    const dirname = path.dirname(relativePath);\n    return {\n      label: `$(file) ${basename}`,\n      description: dirname === "." ? "" : dirname,\n      alwaysShow: true,\n      referer: relativePath,\n      uri: fileItem.uri.toString(),\n      isOpenedInEditor: fileItem.isOpenedInEditor,\n    };\n  });\n  const activeFilesIndex = fileItems.findIndex((item) => item.isOpenedInEditor);\n  if (activeFilesIndex != -1) {\n    fileItems.splice(activeFilesIndex, 0, {\n      label: `active files`,\n      kind: QuickPickItemKind.Separator,\n      referer: "",\n      uri: "",\n      isOpenedInEditor: true,\n    });\n  }\n  const searchResultsIndex = fileItems.findIndex((item) => !item.isOpenedInEditor);\n  if (searchResultsIndex != -1) {\n    fileItems.splice(searchResultsIndex, 0, {\n      label: `search results`,\n      kind: QuickPickItemKind.Separator,\n      referer: "",\n      uri: "",\n      isOpenedInEditor: false,\n    });\n  }\n  return fileItems;\n};\n\ninterface ContextQuickPickItem extends QuickPickItem {\n  type: undefined | "file" | "symbol";\n}\n\nexport class UserCommandQuickpick {\n  quickPick = window.createQuickPick<CommandQuickPickItem>();\n  private suggestedCommand: ChatEditCommand[] = [];\n  private resultDeferred = new Deferred<InlineEditCommand | undefined>();\n  private fetchingSuggestedCommandCancellationTokenSource = new CancellationTokenSource();\n  private lastInputValue = "";\n  private filePick: FileSelectionQuickPick | undefined;\n  private symbolPick: SymbolSelectionQuickPick | undefined;\n  private showingContextPicker = false;\n  private referenceMap = new Map<string, Omit<ChatEditFileContext, "referrer">>();\n\n  constructor(\n    private client: Client,\n    private config: Config,\n    private editLocation: Location,\n  ) {}\n\n  start() {\n    this.quickPick.title = "Enter the command for editing (type @ to include file or symbol)";\n    this.quickPick.matchOnDescription = true;\n    this.quickPick.onDidChangeValue(() => this.handleValueChange());\n    this.quickPick.onDidAccept(() => this.handleAccept());\n    this.quickPick.onDidHide(() => this.handleHidden());\n    this.quickPick.onDidTriggerItemButton((e) => this.handleTriggerItemButton(e));\n\n    this.quickPick.show();\n    this.quickPick.ignoreFocusOut = true;\n    this.provideEditCommands();\n    return this.resultDeferred.promise;\n  }\n\n  private get inputParseResult(): InlineEditParseResult {\n    return parseUserCommand(this.quickPick.value);\n  }\n\n  private handleValueChange() {\n    const { mentionQuery } = this.inputParseResult;\n    if (mentionQuery === "") {\n      this.showingContextPicker = true;\n      this.quickPick.hide();\n      this.showContextPicker();\n    } else {\n      this.updateQuickPickList();\n      this.updateQuickPickValue(this.quickPick.value);\n    }\n  }\n\n  private async showContextPicker() {\n    const contextPicker = window.createQuickPick<ContextQuickPickItem | FileSelectionQuickPickItem>();\n    contextPicker.title = "Select context or file";\n    contextPicker.buttons = [QuickInputButtons.Back];\n    contextPicker.ignoreFocusOut = true;\n    // Quick pick items are always sorted by label. issue: https://github.com/microsoft/vscode/issues/73904\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (contextPicker as any).sortByLabel = false;\n\n    const contextTypeItems: ContextQuickPickItem[] = [\n      { label: "context", kind: QuickPickItemKind.Separator, type: undefined },\n      { label: "$(folder) Files $(chevron-right)", type: "file" },\n      { label: "$(symbol-class) Symbols $(chevron-right)", type: "symbol" },\n    ];\n\n    contextPicker.busy = true;\n    const fileItemsMaxResult = 20;\n    const fileItems = await getFileItems("", fileItemsMaxResult);\n    contextPicker.items = [...contextTypeItems, ...fileItems];\n    contextPicker.busy = false;\n    contextPicker.onDidChangeValue(async (value) => {\n      if (value) {\n        contextPicker.busy = true;\n        const filteredFileItems = await getFileItems(value, fileItemsMaxResult);\n        contextPicker.items = [...contextTypeItems, ...filteredFileItems];\n        contextPicker.busy = false;\n      } else {\n        contextPicker.items = [...contextTypeItems, ...fileItems];\n      }\n    });\n\n    const deferred = new Deferred<ContextQuickPickItem | FileSelectionQuickPickItem | undefined>();\n\n    contextPicker.onDidAccept(() => {\n      deferred.resolve(contextPicker.selectedItems[0]);\n      contextPicker.hide();\n    });\n\n    contextPicker.onDidHide(() => {\n      deferred.resolve(undefined);\n      contextPicker.dispose();\n    });\n\n    contextPicker.onDidTriggerButton((e: QuickInputButton) => {\n      if (e === QuickInputButtons.Back) {\n        contextPicker.hide();\n      }\n    });\n\n    contextPicker.show();\n\n    const result = await deferred.promise;\n\n    if (result && "type" in result) {\n      if (result.type === "file") {\n        await this.openFilePick();\n      } else if (result.type === "symbol") {\n        await this.openSymbolPick();\n      }\n    } else if (result && "uri" in result) {\n      this.quickPick.show();\n      this.updateQuickPickValue(this.quickPick.value + `${result.referer} `);\n      this.referenceMap.set(result.referer, { uri: result.uri });\n    } else {\n      this.quickPick.show();\n      if (this.quickPick.value.endsWith("@")) {\n        this.updateQuickPickValue(replaceLastOccurrence(this.quickPick.value, "@", ""));\n      }\n    }\n  }\n\n  private async openFilePick() {\n    this.filePick = new FileSelectionQuickPick();\n    const file = await this.filePick.start();\n    this.quickPick.show();\n    if (file) {\n      this.updateQuickPickValue(this.quickPick.value + `${file.referer} `);\n      this.referenceMap.set(file.referer, { uri: file.uri });\n    } else {\n      this.updateQuickPickValue(replaceLastOccurrence(this.quickPick.value, "@", ""));\n    }\n    this.filePick = undefined;\n  }\n\n  private async openSymbolPick() {\n    this.symbolPick = new SymbolSelectionQuickPick();\n    const symbol = await this.symbolPick.start();\n    this.quickPick.show();\n    if (symbol) {\n      this.updateQuickPickValue(this.quickPick.value + `${symbol.referer} `);\n      this.referenceMap.set(symbol.referer, { uri: symbol.uri, range: symbol.range });\n    } else {\n      this.updateQuickPickValue(replaceLastOccurrence(this.quickPick.value, "@", ""));\n    }\n    this.symbolPick = undefined;\n  }\n\n  private updateQuickPickValue(value: string) {\n    const lastQuickPickValue = this.lastInputValue;\n    const lastMentionQuery = parseUserCommand(lastQuickPickValue).mentionQuery;\n    const currentMentionQuery = parseUserCommand(value).mentionQuery;\n    // remove whole `@file` part when user start delete on the last `@file`\n    if (\n      lastMentionQuery !== undefined &&\n      currentMentionQuery !== undefined &&\n      currentMentionQuery.length < lastMentionQuery.length\n    ) {\n      this.quickPick.value = replaceLastOccurrence(value, `@${currentMentionQuery}`, "");\n    } else {\n      this.quickPick.value = value;\n    }\n    this.lastInputValue = this.quickPick.value;\n  }\n\n  private async updateQuickPickList() {\n    const command = this.quickPick.value;\n    const list = this.getCommandList(command);\n    this.quickPick.items = list;\n  }\n\n  private getCommandList(input: string) {\n    const list: (QuickPickItem & { value: string })[] = [];\n    list.push({\n      label: "commands",\n      value: "",\n      kind: QuickPickItemKind.Separator,\n    });\n    list.push(\n      ...this.suggestedCommand.map((item) => ({\n        label: item.label,\n        value: item.command,\n        iconPath: new ThemeIcon("sparkle"),\n        description: item.source === "preset" ? item.command : "",\n      })),\n    );\n    list.push({\n      label: "history",\n      value: "",\n      kind: QuickPickItemKind.Separator,\n    });\n    const recentlyCommandToAdd = this.getCommandHistory().filter((item) => !list.find((i) => i.value === item.command));\n    recentlyCommandToAdd.forEach((command) => {\n      if (command.context) {\n        command.context.forEach((context) => {\n          if (!this.referenceMap.has(context.referrer)) {\n            // this context maybe outdated\n            this.referenceMap.set(context.referrer, {\n              uri: context.uri,\n              range: context.range,\n            });\n          }\n        });\n      }\n    });\n    list.push(\n      ...recentlyCommandToAdd.map((item) => ({\n        label: item.command,\n        value: item.command,\n        iconPath: new ThemeIcon("history"),\n        buttons: [\n          {\n            iconPath: new ThemeIcon("edit"),\n          },\n          {\n            iconPath: new ThemeIcon("settings-remove"),\n          },\n        ],\n      })),\n    );\n    if (input.length > 0 && !list.find((i) => i.value === input)) {\n      list.unshift({\n        label: input,\n        value: input,\n        iconPath: new ThemeIcon("run"),\n        description: "",\n        alwaysShow: true,\n      });\n    }\n\n    return list;\n  }\n\n  private handleAccept() {\n    const command = this.quickPick.selectedItems[0]?.value || this.quickPick.value;\n    this.acceptCommand(command);\n  }\n\n  private getCommandHistory(): InlineEditCommand[] {\n    const recentlyCommand = this.config.chatEditRecentlyCommand.slice(0, this.config.maxChatEditHistory);\n    return recentlyCommand.map<InlineEditCommand>((commandStr) => {\n      try {\n        const command = JSON.parse(commandStr);\n        if (typeof command === "object" && command.command) {\n          return {\n            command: command.command,\n            context: command.context,\n          };\n        }\n        return {\n          command: commandStr,\n        };\n      } catch (error) {\n        return {\n          command: commandStr,\n        };\n      }\n    });\n  }\n\n  private async addCommandHistory(userCommand: InlineEditCommand) {\n    const commandStr = JSON.stringify(userCommand);\n    const recentlyCommand = this.config.chatEditRecentlyCommand;\n    const updatedRecentlyCommand = [commandStr]\n      .concat(recentlyCommand.filter((item) => item !== commandStr))\n      .slice(0, this.config.maxChatEditHistory);\n    await this.config.updateChatEditRecentlyCommand(updatedRecentlyCommand);\n  }\n\n  private async deleteCommandHistory(command: string) {\n    const recentlyCommand = this.getCommandHistory();\n    const index = recentlyCommand.findIndex((item) => item.command === command);\n    if (index !== -1) {\n      recentlyCommand.splice(index, 1);\n      await this.config.updateChatEditRecentlyCommand(recentlyCommand.map((command) => JSON.stringify(command)));\n      this.updateQuickPickList();\n    }\n  }\n\n  private async acceptCommand(command: string | undefined) {\n    if (!command) {\n      this.resultDeferred.resolve(undefined);\n      return;\n    }\n    if (command && command.length > 200) {\n      window.showErrorMessage("Command is too long.");\n      this.resultDeferred.resolve(undefined);\n      return;\n    }\n\n    const parseResult = parseUserCommand(command);\n    const mentionTexts = parseResult.mentions?.map((mention) => mention.text) || [];\n    const uniqueMentionTexts = Array.from(new Set(mentionTexts));\n\n    const userCommand = {\n      command,\n      context: uniqueMentionTexts\n        .map<ChatEditFileContext | undefined>((item) => {\n          if (this.referenceMap.has(item)) {\n            const contextInfo = this.referenceMap.get(item);\n            if (contextInfo) {\n              return {\n                uri: contextInfo.uri,\n                referrer: item,\n                range: contextInfo.range,\n              };\n            }\n          }\n          return;\n        })\n        .filter((item): item is ChatEditFileContext => item !== undefined),\n    };\n\n    await this.addCommandHistory(userCommand);\n\n    this.resultDeferred.resolve(userCommand);\n    this.quickPick.hide();\n  }\n\n  private handleHidden() {\n    this.fetchingSuggestedCommandCancellationTokenSource.cancel();\n    const inFileOrSymbolSelection = this.filePick !== undefined || this.symbolPick !== undefined;\n    if (!inFileOrSymbolSelection && !this.showingContextPicker) {\n      this.resultDeferred.resolve(undefined);\n    }\n    this.showingContextPicker = false;\n  }\n\n  private provideEditCommands() {\n    this.client.chat.provideEditCommands(\n      { location: this.editLocation },\n      { commands: this.suggestedCommand, callback: () => this.updateQuickPickList() },\n      this.fetchingSuggestedCommandCancellationTokenSource.token,\n    );\n  }\n\n  private async handleTriggerItemButton(event: QuickPickItemButtonEvent<CommandQuickPickItem>) {\n    const item = event.item;\n    const button = event.button;\n    if (button.iconPath instanceof ThemeIcon && button.iconPath.id === "settings-remove") {\n      this.deleteCommandHistory(item.value);\n    }\n\n    if (button.iconPath instanceof ThemeIcon && button.iconPath.id === "edit") {\n      this.updateQuickPickValue(item.value);\n    }\n  }\n}\n\ninterface FileSelectionQuickPickItem extends QuickPickItem {\n  uri: string;\n  referer: string;\n  isOpenedInEditor: boolean;\n}\n\nexport class FileSelectionQuickPick {\n  quickPick = window.createQuickPick<FileSelectionQuickPickItem>();\n  private maxSearchFileResult = 50;\n  private resultDeferred = new Deferred<FileSelectionQuickPickItem | undefined>();\n\n  start() {\n    this.quickPick.title = "Enter file name to search";\n    this.quickPick.buttons = [QuickInputButtons.Back];\n    this.quickPick.ignoreFocusOut = true;\n    // Quick pick items are always sorted by label. issue: https://github.com/microsoft/vscode/issues/73904\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.quickPick as any).sortByLabel = false;\n    this.quickPick.onDidChangeValue((e) => this.updateFileList(e));\n    this.quickPick.onDidAccept(() => this.handleAccept());\n    this.quickPick.onDidHide(() => this.handleHidden());\n    this.quickPick.onDidTriggerButton((e) => this.handleTriggerButton(e));\n    this.quickPick.show();\n    this.updateFileList("");\n    return this.resultDeferred.promise;\n  }\n\n  private async updateFileList(val: string) {\n    this.quickPick.busy = true;\n    this.quickPick.items = await getFileItems(val, this.maxSearchFileResult);\n    this.quickPick.busy = false;\n  }\n\n  private handleAccept() {\n    this.resultDeferred.resolve(this.quickPick.selectedItems[0]);\n  }\n\n  private handleHidden() {\n    this.resultDeferred.resolve(undefined);\n  }\n\n  private handleTriggerButton(e: QuickInputButton) {\n    if (e === QuickInputButtons.Back) {\n      this.quickPick.hide();\n    }\n  }\n}\n\ninterface SymbolSelectionQuickPickItem extends QuickPickItem {\n  uri: string;\n  referer: string;\n  range?: Range;\n}\n\nexport class SymbolSelectionQuickPick {\n  quickPick = window.createQuickPick<SymbolSelectionQuickPickItem>();\n  private resultDeferred = new Deferred<SymbolSelectionQuickPickItem | undefined>();\n\n  start() {\n    this.quickPick.title = "Enter symbol name to search";\n    this.quickPick.buttons = [QuickInputButtons.Back];\n    this.quickPick.ignoreFocusOut = true;\n    this.quickPick.onDidChangeValue((e) => this.updateSymbolList(e));\n    this.quickPick.onDidAccept(() => this.handleAccept());\n    this.quickPick.onDidHide(() => this.handleHidden());\n    this.quickPick.onDidTriggerButton((e) => this.handleTriggerButton(e));\n    this.quickPick.show();\n    this.updateSymbolList("");\n    return this.resultDeferred.promise;\n  }\n\n  private async updateSymbolList(query: string) {\n    this.quickPick.busy = true;\n    const symbolList = await this.fetchSymbolList(query);\n    this.quickPick.items = symbolList;\n    this.quickPick.busy = false;\n  }\n\n  private handleAccept() {\n    this.resultDeferred.resolve(this.quickPick.selectedItems[0]);\n  }\n\n  private handleHidden() {\n    this.resultDeferred.resolve(undefined);\n  }\n\n  private handleTriggerButton(e: QuickInputButton) {\n    if (e === QuickInputButtons.Back) {\n      this.quickPick.hide();\n    }\n  }\n\n  private listSymbols = wrapCancelableFunction(\n    listSymbols,\n    () => undefined,\n    (args) => args,\n  );\n\n  private async fetchSymbolList(query: string): Promise<SymbolSelectionQuickPickItem[]> {\n    if (!window.activeTextEditor) {\n      return [];\n    }\n    try {\n      const symbols = await this.listSymbols(window.activeTextEditor.document.uri, query, 50);\n      return symbols.map(\n        (symbol) =>\n          ({\n            label: symbol.name,\n            description: symbol.containerName,\n            iconPath: symbol.kindIcon,\n            uri: symbol.location.uri.toString(),\n            referer: symbol.name.replace(/\\s/g, "_").replace(/@/g, ""),\n            // FIXME(icycode): extract type conversion utils\n            range: symbol.location.range\n              ? {\n                  start: {\n                    line: symbol.location.range.start.line,\n                    character: symbol.location.range.start.character,\n                  },\n                  end: {\n                    line: symbol.location.range.end.line,\n                    character: symbol.location.range.end.character,\n                  },\n                }\n              : undefined,\n          }) as SymbolSelectionQuickPickItem,\n      );\n    } catch (error) {\n      return [];\n    }\n  }\n}\n',
            isTruncated: false,
          },
          toolName: "readFile",
          toolCallId: "toolu_vrtx_01MWMiL9m8cM1Wot9yViP9AT",
        },
      },
      {
        type: "step-start",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/inline-edit/util.ts",
          },
          step: 3,
          state: "result",
          result: {
            content:
              'export enum MentionType {\n  File = "file",\n  Symbol = "symbol",\n}\n\nexport interface Mention {\n  /**\n   * The text of the mention (without the @ prefix)\n   */\n  text: string;\n  /**\n   * The type of the mention\n   */\n  type: MentionType;\n}\n\nexport interface InlineEditParseResult {\n  /**\n   * mentions, start with \'@\'\n   */\n  mentions?: Mention[];\n  /**\n   * last mention in the end of user commnad.\n   * for `explain @`, mentionQuery is `\'\'`,  we can trigger pick\n   * for `explain @file`, mentionQuery is `file`,  we know user is editing the mention\n   * for `explain @file to me`, mentionQuery is `undefined`\n   */\n  mentionQuery?: string;\n}\n\nexport const parseUserCommand = (input: string): InlineEditParseResult => {\n  const mentions: Mention[] = [];\n  // Match @text (both file and symbol mentions use the same @ prefix)\n  const regex = /(?<=\\s|^)@(\\S*)/g;\n  let match;\n  const matches = [];\n\n  while ((match = regex.exec(input)) !== null) {\n    const text = match[1];\n    if (text) {\n      mentions.push({\n        text,\n        // Default to File type, will be updated when the mention is resolved\n        type: MentionType.File,\n      });\n    }\n    matches.push(match);\n  }\n\n  let mentionQuery = undefined;\n  if (matches.length > 0) {\n    const lastMatch = matches[matches.length - 1];\n    if (lastMatch) {\n      const endPos = lastMatch.index + lastMatch[0].length;\n      if (endPos === input.length) {\n        mentionQuery = lastMatch[1] || "";\n      }\n    }\n  }\n\n  return {\n    mentions,\n    mentionQuery: mentionQuery !== undefined ? mentionQuery : undefined,\n  };\n};\n\nexport const replaceLastOccurrence = (str: string, substrToReplace: string, replacementStr: string): string => {\n  const lastIndex = str.lastIndexOf(substrToReplace);\n\n  if (lastIndex === -1) {\n    return str;\n  }\n\n  return str.substring(0, lastIndex) + replacementStr + str.substring(lastIndex + substrToReplace.length);\n};\n',
            isTruncated: false,
          },
          toolName: "readFile",
          toolCallId: "toolu_vrtx_015eYLE3vuWsRtjUsBi9h6cB",
        },
      },
      {
        type: "step-start",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/inline-edit/util.test.ts",
          },
          step: 4,
          state: "result",
          result: {
            content:
              'import { describe } from "mocha";\nimport { expect } from "chai";\nimport { parseUserCommand, InlineEditParseResult, MentionType } from "./util";\n\ndescribe("parseInput", () => {\n  it("should parse input correctly", () => {\n    const input = `this is a user command`;\n\n    const parseResult: InlineEditParseResult = {\n      mentions: [],\n      mentionQuery: undefined,\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = `@file1`;\n\n    const parseResult: InlineEditParseResult = {\n      mentions: [{ text: "file1", type: MentionType.File }],\n      mentionQuery: "file1",\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = `@`;\n\n    const parseResult: InlineEditParseResult = {\n      mentions: [],\n      mentionQuery: "",\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = `this is a user command @`;\n\n    const parseResult: InlineEditParseResult = {\n      mentions: [],\n      mentionQuery: "",\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = `this is a user command@`;\n\n    const parseResult: InlineEditParseResult = {\n      mentions: [],\n      mentionQuery: undefined,\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = ` @file1`;\n\n    const parseResult: InlineEditParseResult = {\n      mentions: [{ text: "file1", type: MentionType.File }],\n      mentionQuery: "file1",\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = `@file1 `;\n\n    const parseResult: InlineEditParseResult = {\n      mentions: [{ text: "file1", type: MentionType.File }],\n      mentionQuery: undefined,\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = `@file1 @file2`;\n    const parseResult: InlineEditParseResult = {\n      mentions: [\n        { text: "file1", type: MentionType.File },\n        { text: "file2", type: MentionType.File },\n      ],\n      mentionQuery: "file2",\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = `@file1 @file2 `;\n    const parseResult: InlineEditParseResult = {\n      mentions: [\n        { text: "file1", type: MentionType.File },\n        { text: "file2", type: MentionType.File },\n      ],\n      mentionQuery: undefined,\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = ` @file1 @file2 this is a user command`;\n    const parseResult: InlineEditParseResult = {\n      mentions: [\n        { text: "file1", type: MentionType.File },\n        { text: "file2", type: MentionType.File },\n      ],\n      mentionQuery: undefined,\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = ` @file1 @file2 this is a user command@file3`;\n    const parseResult: InlineEditParseResult = {\n      mentions: [\n        { text: "file1", type: MentionType.File },\n        { text: "file2", type: MentionType.File },\n      ],\n      mentionQuery: undefined,\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = ` @file1 @file2 this is a user command @file3`;\n    const parseResult: InlineEditParseResult = {\n      mentions: [\n        { text: "file1", type: MentionType.File },\n        { text: "file2", type: MentionType.File },\n        { text: "file3", type: MentionType.File },\n      ],\n      mentionQuery: "file3",\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = ` this is a user command @file3 `;\n    const parseResult: InlineEditParseResult = {\n      mentions: [{ text: "file3", type: MentionType.File }],\n      mentionQuery: undefined,\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n\n  it("should parse input correctly", () => {\n    const input = ` this is a @file3  user command `;\n    const parseResult: InlineEditParseResult = {\n      mentions: [{ text: "file3", type: MentionType.File }],\n      mentionQuery: undefined,\n    };\n    expect(parseUserCommand(input)).to.deep.equal(parseResult);\n  });\n});\n',
            isTruncated: false,
          },
          toolName: "readFile",
          toolCallId: "toolu_vrtx_012HBbf3qUCHrmGXk3pre2mK",
        },
      },
      {
        type: "step-start",
      },
      {
        text: "Now I'll examine the VSCode client's main file to understand how the inline-edit feature is integrated.",
        type: "text",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/extension.ts",
          },
          step: 5,
          state: "result",
          result: {
            content:
              'import { window, ExtensionContext } from "vscode";\nimport { getLogger } from "./logger";\nimport { Client, createClient } from "./lsp/client";\nimport { InlineCompletionProvider } from "./InlineCompletionProvider";\nimport { Config } from "./Config";\nimport { GitProvider } from "./git/GitProvider";\nimport { ContextVariables } from "./ContextVariables";\nimport { StatusBarItem } from "./StatusBarItem";\nimport { ChatSidePanelProvider } from "./chat/sidePanel";\nimport { Commands } from "./commands";\nimport { init as initFindFiles } from "./findFiles";\nimport { CodeActions } from "./CodeActions";\nimport { KeyBindingManager } from "./keybindings";\n\nconst logger = getLogger();\nlet clientRef: Client | undefined = undefined;\n\nexport async function activate(context: ExtensionContext) {\n  logger.info("Activating Tabby extension...");\n\n  const client = createClient(context, logger);\n  const config = new Config(context);\n  const contextVariables = new ContextVariables(client, config);\n  const inlineCompletionProvider = new InlineCompletionProvider(client, config);\n  const gitProvider = new GitProvider();\n\n  client.registerConfigManager(config);\n  client.registerInlineCompletionProvider(inlineCompletionProvider);\n  client.registerGitProvider(gitProvider);\n  clientRef = client;\n\n  // Register chat panel\n  const chatViewProvider = new ChatSidePanelProvider(context, client, contextVariables, gitProvider);\n  context.subscriptions.push(\n    window.registerWebviewViewProvider("tabby.chatView", chatViewProvider, {\n      webviewOptions: { retainContextWhenHidden: true },\n    }),\n  );\n\n  // Register status bar item\n  const statusBarItem = new StatusBarItem(client, config);\n  statusBarItem.registerInContext(context);\n\n  // Register command\n  const commands = new Commands(\n    context,\n    client,\n    config,\n    contextVariables,\n    inlineCompletionProvider,\n    chatViewProvider,\n    gitProvider,\n  );\n  commands.register();\n\n  // init keybinding manager\n  KeyBindingManager.getInstance().init();\n\n  // Register code actions\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */ /* eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error */\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */ // @ts-ignore noUnusedLocals\n  const codeActions = new CodeActions(client, contextVariables);\n\n  logger.info("Tabby extension activated.");\n\n  // Start async initialization\n  const startClient = async () => {\n    await gitProvider.init();\n\n    logger.info("Launching language server tabby-agent...");\n    await client.start();\n    logger.info("Language server tabby-agent launched.");\n  };\n\n  await Promise.all([\n    // start LSP client\n    startClient(),\n\n    // findFiles preheat\n    initFindFiles(context),\n  ]);\n\n  const tryReadAuthenticationToken = async (): Promise<{ token: string | undefined }> => {\n    const endpoint = config.serverEndpoint;\n    if (!endpoint || endpoint.trim() === "") {\n      return { token: undefined };\n    }\n\n    const response = await window.showInformationMessage(\n      "Do you consent to sharing your Tabby token with another VSCode extension?",\n      {\n        modal: true,\n        detail: `The extension requests your token to access the Tabby server at ${endpoint}. Sharing your token allows the extension to perform actions as if it were you. Only proceed if you trust the extension.`,\n      },\n      "Yes",\n      "No",\n    );\n\n    if (response === "Yes") {\n      return { token: config.serverRecords.get(endpoint)?.token };\n    }\n    return { token: undefined };\n  };\n  return {\n    tryReadAuthenticationToken,\n  };\n}\n\nexport async function deactivate() {\n  logger.info("Deactivating Tabby extension...");\n  await clientRef?.stop();\n  logger.info("Tabby extension deactivated.");\n}\n',
            isTruncated: false,
          },
          toolName: "readFile",
          toolCallId: "toolu_vrtx_01YD9dhXdFXd5UgFaYnFS3X3",
        },
      },
      {
        type: "step-start",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/commands/index.ts",
          },
          step: 6,
          state: "result",
          result: {
            content:
              'import {\n  workspace,\n  window,\n  env,\n  commands,\n  ExtensionContext,\n  CancellationTokenSource,\n  Uri,\n  ProgressLocation,\n  ThemeIcon,\n  TextEditor,\n  Range,\n  CodeAction,\n  CodeActionKind,\n} from "vscode";\nimport os from "os";\nimport path from "path";\nimport { StatusIssuesName } from "tabby-agent";\nimport { Client } from "../lsp/client";\nimport { Config } from "../Config";\nimport { ContextVariables } from "../ContextVariables";\nimport { InlineCompletionProvider } from "../InlineCompletionProvider";\nimport { ChatSidePanelProvider } from "../chat/sidePanel";\nimport { createChatPanel } from "../chat/chatPanel";\nimport { getEditorContext } from "../chat/context";\nimport { GitProvider, Repository } from "../git/GitProvider";\nimport { showOutputPanel } from "../logger";\nimport { InlineEditController } from "../inline-edit";\nimport { CommandPalette } from "./commandPalette";\nimport { ConnectToServerWidget } from "./connectToServer";\nimport { BranchQuickPick } from "./branchQuickPick";\nimport { getTerminalContext } from "../terminal";\n\nexport class Commands {\n  private chatEditCancellationTokenSource: CancellationTokenSource | null = null;\n\n  constructor(\n    private readonly context: ExtensionContext,\n    private readonly client: Client,\n    private readonly config: Config,\n    private readonly contextVariables: ContextVariables,\n    private readonly inlineCompletionProvider: InlineCompletionProvider,\n    private readonly chatSidePanelProvider: ChatSidePanelProvider,\n    private readonly gitProvider: GitProvider,\n  ) {}\n\n  register() {\n    const registrations = Object.entries(this.commands).map(([key, handler]) => {\n      const commandName = `tabby.${key}`;\n      return commands.registerCommand(commandName, handler, this);\n    });\n    this.context.subscriptions.push(...registrations);\n  }\n\n  commands: Record<string, (...args: never[]) => void> = {\n    applyCallback: (callback: (() => void) | undefined) => {\n      callback?.();\n    },\n    toggleInlineCompletionTriggerMode: async (value: "automatic" | "manual" | undefined) => {\n      let target = value;\n      if (!target) {\n        if (this.config.inlineCompletionTriggerMode === "automatic") {\n          target = "manual";\n        } else {\n          target = "automatic";\n        }\n      }\n      await this.config.updateInlineCompletionTriggerMode(target);\n    },\n    connectToServer: async (endpoint?: string | undefined) => {\n      if (endpoint !== undefined) {\n        await this.config.updateServerEndpoint(endpoint);\n      } else {\n        const widget = new ConnectToServerWidget(this.client, this.config);\n        widget.show();\n      }\n    },\n    reconnectToServer: async () => {\n      await this.client.status.fetchAgentStatusInfo({ recheckConnection: true });\n    },\n    updateToken: async (token?: string | undefined) => {\n      const endpoint = this.config.serverEndpoint;\n      if (token) {\n        if (endpoint == "") {\n          return;\n        }\n        const serverRecords = this.config.serverRecords;\n        serverRecords.set(endpoint, { token, updatedAt: Date.now() });\n        await this.config.updateServerRecords(serverRecords);\n      } else {\n        if (endpoint == "") {\n          await commands.executeCommand("tabby.openTabbyAgentSettings");\n        } else {\n          const widget = new ConnectToServerWidget(this.client, this.config);\n          widget.showUpdateTokenWidget();\n        }\n      }\n    },\n    openSettings: () => {\n      commands.executeCommand("workbench.action.openSettings", "@ext:TabbyML.vscode-tabby");\n    },\n    openTabbyAgentSettings: () => {\n      if (env.appHost !== "desktop") {\n        window.showWarningMessage("Tabby Agent config file is not supported in browser.", { modal: true });\n        return;\n      }\n      const agentUserConfig = Uri.joinPath(Uri.file(os.homedir()), ".tabby-client", "agent", "config.toml");\n      workspace.fs.stat(agentUserConfig).then(\n        () => {\n          workspace.openTextDocument(agentUserConfig).then((document) => {\n            window.showTextDocument(document);\n          });\n        },\n        () => {\n          window.showWarningMessage("Failed to open Tabby Agent config file.", { modal: true });\n        },\n      );\n    },\n    openOnlineHelp: (path?: string | undefined) => {\n      if (typeof path === "string" && path.length > 0) {\n        env.openExternal(Uri.parse(`https://tabby.tabbyml.com${path}`));\n        return;\n      }\n      window\n        .showQuickPick([\n          {\n            label: "Website",\n            iconPath: new ThemeIcon("book"),\n            alwaysShow: true,\n            description: "Visit Tabby\'s website to learn more about features and use cases",\n          },\n          {\n            label: "Tabby Slack Community",\n            description: "Join Tabby\'s Slack community to get help or share feedback",\n            iconPath: new ThemeIcon("comment-discussion"),\n            alwaysShow: true,\n          },\n          {\n            label: "Tabby GitHub Repository",\n            description: "Open issues for bugs or feature requests",\n            iconPath: new ThemeIcon("github"),\n            alwaysShow: true,\n          },\n        ])\n        .then((selection) => {\n          if (selection) {\n            switch (selection.label) {\n              case "Website":\n                env.openExternal(Uri.parse("https://www.tabbyml.com/"));\n                break;\n              case "Tabby Slack Community":\n                env.openExternal(Uri.parse("https://links.tabbyml.com/join-slack-extensions/"));\n                break;\n              case "Tabby GitHub Repository":\n                env.openExternal(Uri.parse("https://github.com/tabbyml/tabby"));\n                break;\n            }\n          }\n        });\n    },\n    openExternal: async (url: string) => {\n      await env.openExternal(Uri.parse(url));\n    },\n    openKeybindings: () => {\n      commands.executeCommand("workbench.action.openGlobalKeybindings", "Tabby");\n    },\n    gettingStarted: () => {\n      commands.executeCommand("workbench.action.openWalkthrough", "TabbyML.vscode-tabby#gettingStarted");\n    },\n    "commandPalette.trigger": () => {\n      const commandPalette = new CommandPalette(this.client, this.config);\n      commandPalette.show();\n    },\n    toggleLanguageInlineCompletion: async (languageId?: string) => {\n      if (!languageId) {\n        languageId = window.activeTextEditor?.document.languageId;\n        if (!languageId) {\n          return;\n        }\n      }\n      const isLanguageDisabled = this.config.disabledLanguages.includes(languageId);\n      const disabledLanguages = this.config.disabledLanguages;\n      if (isLanguageDisabled) {\n        await this.config.updateDisabledLanguages(disabledLanguages.filter((lang) => lang !== languageId));\n      } else {\n        await this.config.updateDisabledLanguages([...disabledLanguages, languageId]);\n      }\n    },\n    "outputPanel.focus": () => {\n      showOutputPanel();\n    },\n    "inlineCompletion.trigger": () => {\n      commands.executeCommand("editor.action.inlineSuggest.trigger");\n    },\n    "inlineCompletion.accept": async () => {\n      const editor = window.activeTextEditor;\n      if (!editor) {\n        return;\n      }\n\n      const uri = editor.document.uri;\n      const range = this.inlineCompletionProvider.calcEditedRangeAfterAccept();\n\n      await commands.executeCommand("editor.action.inlineSuggest.commit");\n\n      if (range) {\n        applyQuickFixes(uri, range);\n      }\n    },\n    "inlineCompletion.acceptNextWord": () => {\n      this.inlineCompletionProvider.handleEvent("accept_word");\n      commands.executeCommand("editor.action.inlineSuggest.acceptNextWord");\n    },\n    "inlineCompletion.acceptNextLine": () => {\n      this.inlineCompletionProvider.handleEvent("accept_line");\n      // FIXME: this command move cursor to next line, but we want to move cursor to the end of current line\n      commands.executeCommand("editor.action.inlineSuggest.acceptNextLine");\n    },\n    "inlineCompletion.dismiss": () => {\n      this.inlineCompletionProvider.handleEvent("dismiss");\n      commands.executeCommand("editor.action.inlineSuggest.hide");\n    },\n    "status.addIgnoredIssues": (name: StatusIssuesName) => {\n      this.client.status.editIgnoredIssues({ operation: "add", issues: name });\n    },\n    "status.resetIgnoredIssues": () => {\n      this.client.status.editIgnoredIssues({ operation: "removeAll", issues: [] });\n    },\n    "chat.toggleFocus": async () => {\n      if (await this.chatSidePanelProvider.chatWebview.isFocused()) {\n        await commands.executeCommand("workbench.action.focusActiveEditorGroup");\n      } else {\n        await commands.executeCommand("tabby.chatView.focus");\n      }\n    },\n    "chat.explainCodeBlock": async (/* userCommand?: string */) => {\n      // @FIXME(@icycodes): The `userCommand` is not being used\n      // When invoked from code-action/quick-fix, it contains the error message provided by the IDE\n      ensureHasEditorSelection(async () => {\n        await commands.executeCommand("tabby.chatView.focus");\n        this.chatSidePanelProvider.chatWebview.executeCommand("explain");\n      });\n    },\n    "chat.addRelevantContext": async () => {\n      ensureHasEditorSelection(async (editor) => {\n        await commands.executeCommand("tabby.chatView.focus");\n        const fileContext = await getEditorContext(editor, this.gitProvider, "selection");\n        if (fileContext) {\n          this.chatSidePanelProvider.chatWebview.addRelevantContext(fileContext);\n        }\n      });\n    },\n    "chat.addFileContext": async () => {\n      const editor = window.activeTextEditor;\n      if (editor) {\n        await commands.executeCommand("tabby.chatView.focus");\n        const fileContext = await getEditorContext(editor, this.gitProvider, "file");\n        if (fileContext) {\n          this.chatSidePanelProvider.chatWebview.addRelevantContext(fileContext);\n        }\n      } else {\n        window.showInformationMessage("No active editor.");\n      }\n    },\n    "chat.fixCodeBlock": async () => {\n      ensureHasEditorSelection(async () => {\n        await commands.executeCommand("tabby.chatView.focus");\n        this.chatSidePanelProvider.chatWebview.executeCommand("fix");\n      });\n    },\n    "chat.generateCodeBlockDoc": async () => {\n      ensureHasEditorSelection(async () => {\n        await commands.executeCommand("tabby.chatView.focus");\n        this.chatSidePanelProvider.chatWebview.executeCommand("generate-docs");\n      });\n    },\n    "chat.generateCodeBlockTest": async () => {\n      ensureHasEditorSelection(async () => {\n        await commands.executeCommand("tabby.chatView.focus");\n        this.chatSidePanelProvider.chatWebview.executeCommand("generate-tests");\n      });\n    },\n    "chat.codeReviewCodeBlock": async () => {\n      ensureHasEditorSelection(async () => {\n        await commands.executeCommand("tabby.chatView.focus");\n        this.chatSidePanelProvider.chatWebview.executeCommand("code-review");\n      });\n    },\n    "chat.createPanel": async () => {\n      await createChatPanel(this.context, this.client, this.gitProvider);\n    },\n    "chat.navigate.newChat": async () => {\n      this.chatSidePanelProvider.chatWebview.navigate("new-chat");\n    },\n    "chat.navigate.history": async () => {\n      this.chatSidePanelProvider.chatWebview.navigate("history");\n    },\n    "chat.edit.start": async (\n      fileUri?: string | undefined,\n      range?: Range | undefined,\n      userCommand?: string | undefined,\n    ) => {\n      if (this.contextVariables.chatEditInProgress) {\n        window.setStatusBarMessage("Edit is already in progress.", 3000);\n        return;\n      }\n\n      let editor: TextEditor | undefined;\n      if (fileUri) {\n        try {\n          const uri = Uri.parse(fileUri, true);\n          editor = window.visibleTextEditors.find((editor) => editor.document.uri.toString() === uri.toString());\n        } catch {\n          // ignore\n        }\n      }\n      if (!editor) {\n        editor = window.activeTextEditor;\n      }\n      if (!editor) {\n        return;\n      }\n\n      const editRange = range ?? editor.selection;\n\n      const inlineEditController = new InlineEditController(\n        this.client,\n        this.config,\n        this.contextVariables,\n        editor,\n        editRange,\n      );\n      const cancellationTokenSource = new CancellationTokenSource();\n      this.chatEditCancellationTokenSource = cancellationTokenSource;\n      await inlineEditController.start(userCommand, cancellationTokenSource.token);\n      cancellationTokenSource.dispose();\n      this.chatEditCancellationTokenSource = null;\n    },\n    "chat.edit.stop": async () => {\n      this.chatEditCancellationTokenSource?.cancel();\n      this.chatEditCancellationTokenSource?.dispose();\n      this.chatEditCancellationTokenSource = null;\n    },\n    "chat.edit.accept": async () => {\n      const editor = window.activeTextEditor;\n      if (!editor) {\n        return;\n      }\n      const location = {\n        uri: editor.document.uri.toString(),\n        range: {\n          start: { line: editor.selection.start.line, character: 0 },\n          end: { line: editor.selection.end.line + 1, character: 0 },\n        },\n      };\n      await this.client.chat.resolveEdit({ location, action: "accept" });\n    },\n    "chat.edit.discard": async () => {\n      const editor = window.activeTextEditor;\n      if (!editor) {\n        return;\n      }\n      const location = {\n        uri: editor.document.uri.toString(),\n        range: {\n          start: { line: editor.selection.start.line, character: 0 },\n          end: { line: editor.selection.end.line + 1, character: 0 },\n        },\n      };\n      await this.client.chat.resolveEdit({ location, action: "discard" });\n    },\n    "chat.generateCommitMessage": async (repository?: { rootUri?: Uri }) => {\n      let selectedRepo: Repository | undefined = undefined;\n      if (repository && repository.rootUri) {\n        selectedRepo = this.gitProvider.getRepository(repository.rootUri);\n      }\n      if (!selectedRepo) {\n        const repos = this.gitProvider.getRepositories() ?? [];\n        if (repos.length < 1) {\n          window.showInformationMessage("No Git repositories found.");\n          return;\n        }\n        if (repos.length == 1) {\n          selectedRepo = repos[0];\n        } else {\n          const selected = await window.showQuickPick(\n            repos\n              .map((repo) => {\n                const repoRoot = repo.rootUri.fsPath;\n                return {\n                  label: path.basename(repoRoot),\n                  detail: repoRoot,\n                  iconPath: new ThemeIcon("repo"),\n                  picked: repo.ui.selected,\n                  alwaysShow: true,\n                  value: repo,\n                };\n              })\n              .sort((a, b) => {\n                if (a.detail.startsWith(b.detail)) {\n                  return 1;\n                } else if (b.detail.startsWith(a.detail)) {\n                  return -1;\n                } else {\n                  return a.label.localeCompare(b.label);\n                }\n              }),\n            { placeHolder: "Select a Git repository" },\n          );\n          selectedRepo = selected?.value;\n        }\n      }\n      if (!selectedRepo) {\n        return;\n      }\n      window.withProgress(\n        {\n          location: ProgressLocation.Notification,\n          title: "Generating commit message...",\n          cancellable: true,\n        },\n        async (_, token) => {\n          // Focus on scm view\n          commands.executeCommand("workbench.view.scm");\n          const result = await this.client.chat.generateCommitMessage(\n            { repository: selectedRepo.rootUri.toString() },\n            token,\n          );\n\n          if (result && selectedRepo.inputBox) {\n            selectedRepo.inputBox.value = result.commitMessage;\n\n            if (selectedRepo.state.HEAD) {\n              const currentBranch = selectedRepo.state.HEAD.name;\n              // FIXME(Sma1lboy): let LLM model decide should we create a new branch or not\n              if (currentBranch === "main" || currentBranch === "master") {\n                commands.executeCommand("tabby.chat.generateBranchName", selectedRepo);\n              }\n            }\n          }\n        },\n      );\n    },\n    "chat.generateBranchName": async (repository?: { rootUri?: Uri }) => {\n      let selectedRepo: Repository | undefined = undefined;\n      if (repository && repository.rootUri) {\n        selectedRepo = this.gitProvider.getRepository(repository.rootUri);\n      }\n      if (!selectedRepo) {\n        const repos = this.gitProvider.getRepositories() ?? [];\n        if (repos.length < 1) {\n          window.showInformationMessage("No Git repositories found.");\n          return;\n        }\n        if (repos.length == 1) {\n          selectedRepo = repos[0];\n        } else {\n          const selected = await window.showQuickPick(\n            repos\n              .map((repo) => {\n                const repoRoot = repo.rootUri.fsPath;\n                return {\n                  label: path.basename(repoRoot),\n                  detail: repoRoot,\n                  iconPath: new ThemeIcon("repo"),\n                  picked: repo.ui.selected,\n                  alwaysShow: true,\n                  value: repo,\n                };\n              })\n              .sort((a, b) => {\n                if (a.detail.startsWith(b.detail)) {\n                  return 1;\n                } else if (b.detail.startsWith(a.detail)) {\n                  return -1;\n                } else {\n                  return a.label.localeCompare(b.label);\n                }\n              }),\n            { placeHolder: "Select a Git repository" },\n          );\n          selectedRepo = selected?.value;\n        }\n      }\n      if (!selectedRepo) {\n        return;\n      }\n\n      const branchQuickPick = new BranchQuickPick(this.client, selectedRepo.rootUri.toString());\n\n      const branchName = await branchQuickPick.start();\n      if (branchName) {\n        try {\n          await selectedRepo.createBranch(branchName, true);\n          window.showInformationMessage(`Created branch: ${branchName}`);\n        } catch (error) {\n          window.showErrorMessage(`Failed to create branch: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      }\n    },\n    "terminal.explainSelection": async () => {\n      await commands.executeCommand("tabby.chatView.focus");\n      this.chatSidePanelProvider.chatWebview.executeCommand("explain-terminal");\n    },\n    "terminal.addSelectionToChat": async () => {\n      const terminalContext = await getTerminalContext();\n      if (!terminalContext) {\n        window.showInformationMessage("No terminal selection found.");\n        return;\n      }\n\n      await commands.executeCommand("tabby.chatView.focus");\n      this.chatSidePanelProvider.chatWebview.addRelevantContext(terminalContext);\n    },\n  };\n}\n\nfunction ensureHasEditorSelection(callback: (editor: TextEditor) => void) {\n  const editor = window.activeTextEditor;\n  if (editor && !editor.selection.isEmpty) {\n    callback(editor);\n  } else {\n    window.showInformationMessage("No selected codes.");\n  }\n}\n\nasync function applyQuickFixes(uri: Uri, range: Range): Promise<void> {\n  const codeActions = await commands.executeCommand<CodeAction[]>("vscode.executeCodeActionProvider", uri, range);\n  const quickFixActions = codeActions.filter(\n    (action) =>\n      action.kind && action.kind.contains(CodeActionKind.QuickFix) && action.title.toLowerCase().includes("import"),\n  );\n\n  if (quickFixActions.length === 1 && quickFixActions[0]) {\n    const firstAction = quickFixActions[0];\n    try {\n      if (firstAction.edit) {\n        await workspace.applyEdit(firstAction.edit);\n      }\n      if (firstAction.command) {\n        await commands.executeCommand(firstAction.command.command, firstAction.command.arguments);\n      }\n    } catch (error) {\n      // ignore errors\n    }\n  }\n}\n',
            isTruncated: false,
          },
          toolName: "readFile",
          toolCallId: "toolu_vrtx_0153dcxAGfjyJpZGpTtuVDvP",
        },
      },
      {
        type: "step-start",
      },
      {
        text: "Based on my analysis of the files in the `clients/vscode/src/inline-edit` directory, I can provide a comprehensive explanation of this feature:",
        type: "text",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            result:
              "The `inline-edit` directory in the VSCode client for Tabby implements a feature that allows users to make AI-assisted edits directly within their code editor. Here's a breakdown of its functionality:\n\n## Core Components\n\n1. **InlineEditController** (`index.ts`)\n   - The main controller class that manages the inline editing process\n   - Handles the selection of code to be edited and coordinates with the Tabby LSP client\n   - Locks the cursor position during editing to prevent user interference\n   - Manages the edit workflow from command input to applying changes\n\n2. **QuickPick UI** (`quickPick.ts`)\n   - Provides a user interface for entering edit commands\n   - Allows users to select from suggested commands or enter custom ones\n   - Supports command history for quick access to previously used commands\n   - Enables referencing files and symbols in commands using the `@` syntax\n\n3. **Utility Functions** (`util.ts`)\n   - Contains helper functions for parsing user commands\n   - Handles the extraction of mentions (file/symbol references) from commands\n   - Provides string manipulation utilities\n\n## How It Works\n\n1. The feature is triggered via the `chat.edit.start` command (defined in `commands/index.ts`)\n2. Users select a code block they want to edit\n3. A quick pick dialog appears where users can:\n   - Type a natural language command describing the desired edit\n   - Reference other files or symbols using `@` mentions\n   - Choose from suggested commands or previous commands\n4. The command is sent to the Tabby server which generates the edit\n5. The edit is previewed in the editor and can be accepted or discarded\n\n## Key Features\n\n- **Context-aware editing**: Can reference other files and symbols in the codebase\n- **Command history**: Remembers previously used edit commands\n- **Suggested commands**: Provides AI-generated command suggestions based on the selected code\n- **Preview changes**: Shows the proposed changes before applying them\n- **Cursor locking**: Prevents accidental editing during the AI edit process\n\n## Integration Points\n\nThe inline-edit feature integrates with:\n- VSCode's QuickPick UI components\n- Tabby's LSP client for communication with the Tabby server\n- The editor's selection and document APIs\n- The chat functionality for providing context\n\nThis feature enhances developer productivity by allowing natural language instructions to modify code, leveraging Tabby's AI capabilities to understand and implement the requested changes.",
          },
          step: 7,
          state: "result",
          result: {
            success: true,
          },
          toolName: "attemptCompletion",
          toolCallId: "toolu_vrtx_01BQYs7bATZLJv7p3Bi8DSqZ",
        },
      },
    ],
    content: "",
    createdAt: new Date("2025-05-18T05:20:37.584Z"),
    // revisionId: "zQRoImajqosmFZFK",
  },
  {
    id: "JnCrMmZPMZbnxQJ8",
    role: "user",
    parts: [
      {
        text: "explain <file>clients/vscode/src/chat/html/error.html</file> file usage",
        type: "text",
      },
    ],
    content: "",
    createdAt: new Date("2025-05-18T05:29:16.028Z"),
  },
  {
    id: "msg-2VJA3VTrJ5uZI0I3hB6CKXhj",
    role: "assistant",
    parts: [
      {
        type: "step-start",
      },
      {
        text: "I'll examine the error.html file in the VSCode chat module to understand its usage.",
        type: "text",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/chat/html/error.html",
          },
          step: 0,
          state: "result",
          result: {
            content:
              '<!doctype html>\n<html lang="en">\n  <!--{{RELOAD_COUNT}}-->\n\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <link href="{{URI_STYLESHEET}}" rel="stylesheet" />\n  </head>\n\n  <body>\n    <main class="static-content">\n      <div class="avatar">\n        <img src="{{URI_AVATAR_TABBY}}" />\n        <p>Tabby</p>\n      </div>\n      <h4 class="title">Welcome to Tabby Chat!</h4>\n      <p>{{ERROR_MESSAGE}}</p>\n    </main>\n  </body>\n</html>\n',
            isTruncated: false,
          },
          toolName: "readFile",
          toolCallId: "toolu_vrtx_01HRNTYPsvqAdc8CFWQLi6Ro",
        },
      },
      {
        type: "step-start",
      },
      {
        text: "Now I'll look at how this error.html file is used in the codebase:",
        type: "text",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/chat",
            regex: "error\\.html",
          },
          step: 1,
          state: "result",
          result: {
            matches: [
              {
                file: "clients/vscode/src/chat/webview.ts",
                line: 64,
                context: 'import errorHtml from "./html/error.html";',
              },
            ],
            isTruncated: false,
          },
          toolName: "searchFiles",
          toolCallId: "toolu_vrtx_01Ey1JrEWkw8eq9nzuQAinR3",
        },
      },
      {
        type: "step-start",
      },
      {
        text: "Let me check how the webview.ts file uses the error.html template:",
        type: "text",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/chat/webview.ts",
          },
          step: 2,
          state: "result",
          result: {
            content:
              'import EventEmitter from "events";\nimport {\n  commands,\n  env,\n  window,\n  workspace,\n  Disposable,\n  ExtensionContext,\n  Uri,\n  TextEditor,\n  Range,\n  TextDocument,\n  Webview,\n  ColorThemeKind,\n  ProgressLocation,\n  Location,\n  LocationLink,\n  SymbolInformation,\n  DocumentSymbol,\n} from "vscode";\nimport type {\n  ServerApiList,\n  ChatView,\n  EditorContext,\n  LookupSymbolHint,\n  SymbolInfo,\n  FileLocation,\n  GitRepository,\n  ListFilesInWorkspaceParams,\n  ListFileItem,\n  FileRange,\n  Filepath,\n  ListSymbolsParams,\n  ListSymbolItem,\n  ChangeItem,\n  GetChangesParams,\n  EditorFileContext,\n  TerminalContext,\n  ChatCommand,\n} from "tabby-chat-panel";\nimport * as semver from "semver";\nimport debounce from "debounce";\nimport { v4 as uuid } from "uuid";\nimport type { StatusInfo, Config } from "tabby-agent";\nimport type { GitProvider, Repository } from "../git/GitProvider";\nimport type { Client as LspClient } from "../lsp/client";\nimport { createClient } from "./createClient";\nimport { isBrowser } from "../env";\nimport { getLogger } from "../logger";\nimport { getEditorContext } from "./context";\nimport {\n  localUriToChatPanelFilepath,\n  chatPanelFilepathToLocalUri,\n  vscodePositionToChatPanelPosition,\n  vscodeRangeToChatPanelPositionRange,\n  chatPanelLocationToVSCodeRange,\n  isValidForSyncActiveEditorSelection,\n  vscodeRangeToChatPanelLineRange,\n  isCompatible,\n} from "./utils";\nimport { listFiles } from "../findFiles";\nimport { wrapCancelableFunction } from "../cancelableFunction";\nimport mainHtml from "./html/main.html";\nimport errorHtml from "./html/error.html";\nimport { getTerminalContext } from "../terminal";\n\nexport class ChatWebview extends EventEmitter {\n  private readonly logger = getLogger("ChatWebView");\n  private disposables: Disposable[] = [];\n  private webview: Webview | undefined = undefined;\n  private client: ServerApiList | undefined = undefined;\n\n  // The current server config used to load the chat panel.\n  private currentConfig: Config["server"] | undefined = undefined;\n\n  // A number to ensure the html is reloaded when assigned a new value\n  private reloadCount = 0;\n\n  // Once the chat iframe is loaded, the `createChatPanelApiClient` should be resolved,\n  // and we can start to `initChatPanel`.\n  // So we set a timeout here to ensure the `createChatPanelApiClient` is resolved,\n  // otherwise we will show an error.\n  private createClientTimeout: NodeJS.Timeout | undefined = undefined;\n\n  // Pending actions to perform after the chat panel is initialized.\n  private pendingActions: (() => Promise<void>)[] = [];\n\n  // A callback list for invoke javascript function by postMessage\n  private pendingCallbacks = new Map<string, (...arg: unknown[]) => void>();\n\n  // Store the chat state to be reload when webview is reloaded\n  private sessionStateMap = new Map<string, Record<string, unknown>>();\n\n  constructor(\n    private readonly context: ExtensionContext,\n    private readonly lspClient: LspClient,\n    private readonly gitProvider: GitProvider,\n  ) {\n    super();\n  }\n\n  async init(webview: Webview) {\n    webview.options = {\n      enableScripts: true,\n      enableCommandUris: true,\n    };\n    this.webview = webview;\n\n    const statusListener = () => {\n      this.checkStatusAndLoadContent();\n    };\n    this.lspClient.status.on("didChange", statusListener);\n    this.disposables.push(\n      new Disposable(() => {\n        this.lspClient.status.off("didChange", statusListener);\n      }),\n    );\n    this.checkStatusAndLoadContent();\n\n    this.disposables.push(\n      window.onDidChangeActiveTextEditor((editor) => {\n        if (this.client) {\n          this.debouncedNotifyActiveEditorSelectionChange(editor);\n        }\n      }),\n    );\n    this.disposables.push(\n      window.onDidChangeTextEditorSelection((event) => {\n        if (event.textEditor === window.activeTextEditor && this.client) {\n          this.debouncedNotifyActiveEditorSelectionChange(event.textEditor);\n        }\n      }),\n    );\n\n    this.disposables.push(\n      webview.onDidReceiveMessage((event) => {\n        switch (event.action) {\n          case "chatIframeLoaded": {\n            this.createClientTimeout = setTimeout(() => {\n              const endpoint = this.currentConfig?.endpoint ?? "";\n              if (!endpoint) {\n                this.checkStatusAndLoadContent();\n              } else {\n                const command = `command:tabby.openExternal?${encodeURIComponent(`["${endpoint}/chat"]`)}`;\n                this.loadErrorPage(\n                  `Failed to load the chat panel. <br/>Please check your network to ensure access to <a href=\'${command}\'>${endpoint}/chat</a>. <br/><br/><a href=\'command:tabby.reconnectToServer\'><b>Reload</b></a>`,\n                );\n              }\n            }, 10000);\n            return;\n          }\n          case "syncStyle": {\n            this.client?.["0.8.0"].updateTheme(event.style, this.getColorThemeString());\n            return;\n          }\n          case "jsCallback": {\n            this.pendingCallbacks.get(event.id)?.(...event.args);\n            this.pendingCallbacks.delete(event.id);\n            return;\n          }\n        }\n      }),\n    );\n  }\n\n  async dispose() {\n    this.disposables.forEach((d) => d.dispose());\n    this.disposables = [];\n    this.webview = undefined;\n    this.client = undefined;\n    if (this.createClientTimeout) {\n      clearTimeout(this.createClientTimeout);\n      this.createClientTimeout = undefined;\n    }\n    this.currentConfig = undefined;\n  }\n\n  async isFocused(): Promise<boolean> {\n    const webview = this.webview;\n    if (!webview) {\n      return false;\n    }\n    return new Promise((resolve) => {\n      const id = uuid();\n      this.pendingCallbacks.set(id, (...args) => {\n        resolve(args[0] as boolean);\n      });\n      webview.postMessage({ id, action: "checkFocused" });\n    });\n  }\n\n  getApiVersions(): string[] | undefined {\n    return Object.keys(this.client ?? {}).filter((key) => semver.valid(key));\n  }\n\n  get isTerminalContextEnabled(): boolean {\n    return this.getApiVersions()?.some((version) => isCompatible(version, "0.10.0")) ?? false;\n  }\n\n  setActiveSelection(selection: EditorContext) {\n    if (this.client) {\n      this.logger.info(`Set active selection: ${selection}`);\n      this.client["0.8.0"].updateActiveSelection(selection);\n    } else {\n      this.pendingActions.push(async () => {\n        this.logger.info(`Set pending active selection: ${selection}`);\n        await this.client?.["0.8.0"].updateActiveSelection(selection);\n      });\n    }\n  }\n\n  async addRelevantContext(context: EditorContext) {\n    if (this.client) {\n      this.logger.info(`Adding relevant context: ${context}`);\n      if (context.kind === "terminal") {\n        this.client["0.10.0"]?.addRelevantContext(context);\n      } else {\n        this.client["0.8.0"].addRelevantContext(context);\n      }\n    } else {\n      this.pendingActions.push(async () => {\n        this.logger.info(`Adding pending relevant context: ${context}`);\n        if (context.kind === "terminal") {\n          await this.client?.["0.10.0"]?.addRelevantContext(context);\n        } else {\n          await this.client?.["0.8.0"].addRelevantContext(context);\n        }\n      });\n    }\n  }\n\n  async executeCommand(command: ChatCommand) {\n    if (this.client) {\n      this.logger.info(`Executing command: ${command}`);\n      if (command === "explain-terminal") {\n        this.client["0.10.0"]?.executeCommand(command);\n      } else {\n        this.client["0.8.0"].executeCommand(command);\n      }\n    } else {\n      this.pendingActions.push(async () => {\n        this.logger.info(`Executing pending command: ${command}`);\n        if (command === "explain-terminal") {\n          await this.client?.["0.10.0"]?.executeCommand(command);\n        } else {\n          await this.client?.["0.8.0"].executeCommand(command);\n        }\n      });\n    }\n  }\n\n  async navigate(view: ChatView) {\n    if (this.client) {\n      this.logger.info(`Navigate: ${view}`);\n      this.client["0.8.0"].navigate(view);\n    }\n  }\n\n  private async initChatPanel(webview: Webview) {\n    const client = await this.createChatPanelApiClient(webview);\n    this.client = client;\n    this.emit("didChangedStatus", "ready");\n\n    if (this.createClientTimeout) {\n      clearTimeout(this.createClientTimeout);\n      this.createClientTimeout = undefined;\n    }\n\n    // 1. Send pending actions\n    // 2. Call the client\'s init method\n    // 3. Show the chat panel (call syncStyle underlay)\n    this.pendingActions.forEach(async (fn) => {\n      await fn();\n    });\n    this.pendingActions = [];\n\n    const isMac = isBrowser\n      ? navigator.userAgent.toLowerCase().includes("mac")\n      : process.platform.toLowerCase().includes("darwin");\n\n    await client["0.8.0"].init({\n      fetcherOptions: {\n        authorization: this.currentConfig?.token ?? "",\n      },\n      useMacOSKeyboardEventHandler: isMac,\n    });\n\n    webview.postMessage({ action: "showChatPanel" });\n  }\n\n  private async createChatPanelApiClient(webview: Webview): Promise<ServerApiList> {\n    return await createClient(webview, {\n      refresh: async () => {\n        commands.executeCommand("tabby.reconnectToServer");\n        return;\n      },\n\n      onApplyInEditor: async (content: string) => {\n        const editor = window.activeTextEditor;\n        if (!editor) {\n          window.showErrorMessage("No active editor found.");\n          return;\n        }\n        await this.applyInEditor(editor, content);\n      },\n\n      onApplyInEditorV2: async (content: string, options?: { languageId?: string; smart?: boolean }) => {\n        const editor = window.activeTextEditor;\n        if (!editor) {\n          window.showErrorMessage("No active editor found.");\n          return;\n        }\n        if (!options || !options.smart) {\n          await this.applyInEditor(editor, content);\n        } else if (editor.document.languageId !== options.languageId) {\n          this.logger.debug("Editor\'s languageId:", editor.document.languageId, "opts.languageId:", options.languageId);\n          await this.applyInEditor(editor, content);\n          window.showInformationMessage("The active editor is not in the correct language. Did normal apply.");\n        } else {\n          await this.smartApplyInEditor(editor, content);\n        }\n      },\n\n      onCopy: async (content) => {\n        env.clipboard.writeText(content);\n      },\n\n      onKeyboardEvent: async (type: string, event: KeyboardEventInit) => {\n        this.logger.debug(`Dispatching keyboard event: ${type} ${JSON.stringify(event)}`);\n        this.webview?.postMessage({ action: "dispatchKeyboardEvent", type, event });\n      },\n\n      lookupSymbol: async (symbol: string, hints?: LookupSymbolHint[] | undefined): Promise<SymbolInfo | null> => {\n        if (!symbol.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) {\n          // Do not process invalid symbols\n          return null;\n        }\n        /// FIXME: When no hints provided, try to use `vscode.executeWorkspaceSymbolProvider` to find the symbol.\n\n        // Find the symbol in the hints\n        for (const hint of hints ?? []) {\n          if (!hint.filepath) {\n            this.logger.debug("No filepath in the hint:", hint);\n            continue;\n          }\n          const uri = chatPanelFilepathToLocalUri(hint.filepath, this.gitProvider);\n          if (!uri) {\n            continue;\n          }\n\n          let document: TextDocument;\n          try {\n            document = await workspace.openTextDocument(uri);\n          } catch (error) {\n            this.logger.debug("Failed to open document:", uri, error);\n            continue;\n          }\n          if (!document) {\n            continue;\n          }\n\n          const findSymbolInContent = async (\n            content: string,\n            offsetInDocument: number,\n          ): Promise<SymbolInfo | undefined> => {\n            // Add word boundary to perform exact match\n            const matchRegExp = new RegExp(`\\\\b${symbol}\\\\b`, "g");\n            let match;\n            while ((match = matchRegExp.exec(content)) !== null) {\n              const offset = offsetInDocument + match.index;\n              const position = document.positionAt(offset);\n              const locations = await commands.executeCommand<Location[] | LocationLink[]>(\n                "vscode.executeDefinitionProvider",\n                document.uri,\n                position,\n              );\n              if (locations && locations.length > 0) {\n                const location = locations[0];\n                if (location) {\n                  if ("targetUri" in location) {\n                    const targetLocation = location.targetSelectionRange ?? location.targetRange;\n                    return {\n                      source: {\n                        filepath: localUriToChatPanelFilepath(document.uri, this.gitProvider),\n                        location: vscodePositionToChatPanelPosition(position),\n                      },\n                      target: {\n                        filepath: localUriToChatPanelFilepath(location.targetUri, this.gitProvider),\n                        location: vscodeRangeToChatPanelPositionRange(targetLocation),\n                      },\n                    };\n                  } else if ("uri" in location) {\n                    return {\n                      source: {\n                        filepath: localUriToChatPanelFilepath(document.uri, this.gitProvider),\n                        location: vscodePositionToChatPanelPosition(position),\n                      },\n                      target: {\n                        filepath: localUriToChatPanelFilepath(location.uri, this.gitProvider),\n                        location: vscodeRangeToChatPanelPositionRange(location.range),\n                      },\n                    };\n                  }\n                }\n              }\n            }\n            return undefined;\n          };\n\n          let symbolInfo: SymbolInfo | undefined;\n          if (hint.location) {\n            // Find in the hint location\n            const location = chatPanelLocationToVSCodeRange(hint.location);\n            if (location) {\n              let range: Range;\n              if (!location.isEmpty) {\n                range = location;\n              } else {\n                // a empty range, create a new range with this line to the end of the file\n                range = new Range(location.start.line, 0, document.lineCount, 0);\n              }\n              const content = document.getText(range);\n              const offset = document.offsetAt(range.start);\n              symbolInfo = await findSymbolInContent(content, offset);\n            }\n          }\n          if (!symbolInfo) {\n            // Fallback to find in full content\n            const content = document.getText();\n            symbolInfo = await findSymbolInContent(content, 0);\n          }\n          if (symbolInfo) {\n            // Symbol found\n            this.logger.debug(\n              `Symbol found: ${symbol} with hints: ${JSON.stringify(hints)}: ${JSON.stringify(symbolInfo)}`,\n            );\n            return symbolInfo;\n          }\n        }\n        this.logger.debug(`Symbol not found: ${symbol} with hints: ${JSON.stringify(hints)}`);\n        return null;\n      },\n\n      openInEditor: async (fileLocation: FileLocation): Promise<boolean> => {\n        const uri = chatPanelFilepathToLocalUri(fileLocation.filepath, this.gitProvider);\n        if (!uri) {\n          return false;\n        }\n\n        if (uri.scheme === "output") {\n          try {\n            await commands.executeCommand(`workbench.action.output.show.${uri.fsPath}`);\n            return true;\n          } catch (error) {\n            this.logger.error("Failed to open output channel:", fileLocation, error);\n            return false;\n          }\n        }\n\n        const targetRange = chatPanelLocationToVSCodeRange(fileLocation.location) ?? new Range(0, 0, 0, 0);\n        try {\n          await commands.executeCommand(\n            "editor.action.goToLocations",\n            uri,\n            targetRange.start,\n            [new Location(uri, targetRange)],\n            "goto",\n          );\n          return true;\n        } catch (error) {\n          this.logger.error("Failed to go to location:", fileLocation, error);\n          return false;\n        }\n      },\n\n      openExternal: async (url: string) => {\n        await env.openExternal(Uri.parse(url));\n      },\n\n      readWorkspaceGitRepositories: async (): Promise<GitRepository[]> => {\n        const activeTextEditor = window.activeTextEditor;\n        const infoList: GitRepository[] = [];\n        let activeGitUrl: string | undefined;\n        if (activeTextEditor) {\n          const repo = this.gitProvider.getRepository(activeTextEditor.document.uri);\n          if (repo) {\n            const gitRemoteUrl = this.gitProvider.getDefaultRemoteUrl(repo);\n            if (gitRemoteUrl) {\n              infoList.push({\n                url: gitRemoteUrl,\n              });\n            }\n          }\n        }\n\n        const workspaceFolder = workspace.workspaceFolders ?? [];\n        for (const folder of workspaceFolder) {\n          const repo = this.gitProvider.getRepository(folder.uri);\n          if (repo) {\n            const gitRemoteUrl = this.gitProvider.getDefaultRemoteUrl(repo);\n            if (gitRemoteUrl && gitRemoteUrl !== activeGitUrl) {\n              infoList.push({\n                url: gitRemoteUrl,\n              });\n            }\n          }\n        }\n        return infoList;\n      },\n\n      getActiveEditorSelection: async (): Promise<EditorFileContext | null> => {\n        const editor = window.activeTextEditor;\n        if (!editor || !isValidForSyncActiveEditorSelection(editor)) {\n          return null;\n        }\n\n        return await getEditorContext(editor, this.gitProvider);\n      },\n\n      getActiveTerminalSelection: async (): Promise<TerminalContext | null> => {\n        const terminalContext = await getTerminalContext();\n        if (!terminalContext) {\n          this.logger.warn("No active terminal selection found.");\n          return null;\n        }\n        return terminalContext;\n      },\n\n      fetchSessionState: async (keys?: string[] | undefined): Promise<Record<string, unknown> | null> => {\n        const sessionStateKey = this.currentConfig?.endpoint ?? "";\n        const sessionState = this.sessionStateMap.get(sessionStateKey) ?? {};\n\n        if (!keys) {\n          return { ...sessionState };\n        }\n\n        const filtered: Record<string, unknown> = {};\n        for (const key of keys) {\n          if (key in sessionState) {\n            filtered[key] = sessionState[key];\n          }\n        }\n        return filtered;\n      },\n\n      storeSessionState: async (state: Record<string, unknown>) => {\n        const sessionStateKey = this.currentConfig?.endpoint ?? "";\n        const sessionState = this.sessionStateMap.get(sessionStateKey) ?? {};\n        this.sessionStateMap.set(sessionStateKey, {\n          ...sessionState,\n          ...state,\n        });\n      },\n\n      listFileInWorkspace: async (params: ListFilesInWorkspaceParams): Promise<ListFileItem[]> => {\n        try {\n          const files = await this.listFiles(params.query, params.limit);\n          return files.map((item) => {\n            return {\n              filepath: localUriToChatPanelFilepath(item.uri, this.gitProvider),\n              source: item.isOpenedInEditor ? "openedInEditor" : "searchResult",\n            };\n          });\n        } catch (error) {\n          this.logger.warn("Failed to list files:", error);\n          return [];\n        }\n      },\n\n      readFileContent: async (info: FileRange): Promise<string | null> => {\n        const uri = chatPanelFilepathToLocalUri(info.filepath, this.gitProvider);\n        if (!uri) {\n          this.logger.warn(`Could not resolve URI from filepath: ${JSON.stringify(info.filepath)}`);\n          return null;\n        }\n        const document = await workspace.openTextDocument(uri);\n        return document.getText(chatPanelLocationToVSCodeRange(info.range) ?? undefined);\n      },\n      listSymbols: async (params: ListSymbolsParams): Promise<ListSymbolItem[]> => {\n        const { query } = params;\n        let { limit } = params;\n        const editor = window.activeTextEditor;\n\n        if (!editor) {\n          this.logger.warn("listActiveSymbols: No active editor found.");\n          return [];\n        }\n        if (!limit || limit < 0) {\n          limit = 20;\n        }\n\n        const getDocumentSymbols = async (editor: TextEditor): Promise<SymbolInformation[]> => {\n          this.logger.debug(`getDocumentSymbols: Fetching document symbols for ${editor.document.uri.toString()}`);\n          const symbols =\n            (await commands.executeCommand<DocumentSymbol[] | SymbolInformation[]>(\n              "vscode.executeDocumentSymbolProvider",\n              editor.document.uri,\n            )) || [];\n\n          const result: SymbolInformation[] = [];\n          const queue: (DocumentSymbol | SymbolInformation)[] = [...symbols];\n\n          // BFS to get all symbols up to the limit\n          while (queue.length > 0 && result.length < limit) {\n            const current = queue.shift();\n            if (!current) {\n              continue;\n            }\n\n            if (current instanceof DocumentSymbol) {\n              const converted = new SymbolInformation(\n                current.name,\n                current.kind,\n                current.detail,\n                new Location(editor.document.uri, current.range),\n              );\n\n              result.push(converted);\n\n              if (result.length >= limit) {\n                break;\n              }\n\n              queue.push(...current.children);\n            } else {\n              result.push(current);\n\n              if (result.length >= limit) {\n                break;\n              }\n            }\n          }\n\n          this.logger.debug(`getDocumentSymbols: Found ${result.length} symbols.`);\n          return result;\n        };\n\n        const getWorkspaceSymbols = async (query: string): Promise<ListSymbolItem[]> => {\n          this.logger.debug(`getWorkspaceSymbols: Fetching workspace symbols for query "${query}"`);\n          try {\n            const symbols =\n              (await commands.executeCommand<SymbolInformation[]>("vscode.executeWorkspaceSymbolProvider", query)) ||\n              [];\n\n            const items = symbols.map((symbol) => ({\n              filepath: localUriToChatPanelFilepath(symbol.location.uri, this.gitProvider),\n              range: vscodeRangeToChatPanelLineRange(symbol.location.range),\n              label: symbol.name,\n            }));\n            this.logger.debug(`getWorkspaceSymbols: Found ${items.length} symbols.`);\n            return items;\n          } catch (error) {\n            this.logger.error(`Workspace symbols failed: ${error}`);\n            return [];\n          }\n        };\n\n        const filterSymbols = (symbols: SymbolInformation[], query: string): SymbolInformation[] => {\n          const lowerQuery = query.toLowerCase();\n          const filtered = symbols.filter(\n            (s) => s.name.toLowerCase().includes(lowerQuery) || s.containerName?.toLowerCase().includes(lowerQuery),\n          );\n          this.logger.debug(`filterSymbols: Filtered down to ${filtered.length} symbols with query "${query}"`);\n          return filtered;\n        };\n\n        const mergeResults = (\n          local: ListSymbolItem[],\n          workspace: ListSymbolItem[],\n          query: string,\n          limit = 20,\n        ): ListSymbolItem[] => {\n          this.logger.debug(\n            `mergeResults: Merging ${local.length} local symbols and ${workspace.length} workspace symbols with query "${query}" and limit ${limit}`,\n          );\n\n          const seen = new Set<string>();\n          const allItems = [...local, ...workspace];\n          const uniqueItems: ListSymbolItem[] = [];\n\n          for (const item of allItems) {\n            const key = `${item.filepath}-${item.label}-${item.range.start}-${item.range.end}`;\n            if (!seen.has(key)) {\n              seen.add(key);\n              uniqueItems.push(item);\n            }\n          }\n\n          // Sort all items by the match score\n          const getMatchScore = (label: string): number => {\n            const lowerLabel = label.toLowerCase();\n            const lowerQuery = query.toLowerCase();\n\n            if (lowerLabel === lowerQuery) return 3;\n            if (lowerLabel.startsWith(lowerQuery)) return 2;\n            if (lowerLabel.includes(lowerQuery)) return 1;\n            return 0;\n          };\n\n          uniqueItems.sort((a, b) => {\n            const scoreA = getMatchScore(a.label);\n            const scoreB = getMatchScore(b.label);\n\n            if (scoreB !== scoreA) return scoreB - scoreA;\n            return a.label.length - b.label.length;\n          });\n\n          this.logger.debug(`mergeResults: Returning ${Math.min(uniqueItems.length, limit)} sorted symbols.`);\n          return uniqueItems.slice(0, limit);\n        };\n\n        const symbolToItem = (symbol: SymbolInformation, filepath: Filepath): ListSymbolItem => {\n          return {\n            filepath,\n            range: vscodeRangeToChatPanelLineRange(symbol.location.range),\n            label: symbol.name,\n          };\n        };\n\n        try {\n          this.logger.info("listActiveSymbols: Starting to fetch symbols.");\n          const defaultSymbols = await getDocumentSymbols(editor);\n          const filepath = localUriToChatPanelFilepath(editor.document.uri, this.gitProvider);\n\n          if (!query) {\n            const items = defaultSymbols.slice(0, limit).map((symbol) => symbolToItem(symbol, filepath));\n            this.logger.debug(`listActiveSymbols: Returning ${items.length} symbols.`);\n            return items;\n          }\n\n          const [filteredDefault, workspaceSymbols] = await Promise.all([\n            Promise.resolve(filterSymbols(defaultSymbols, query)),\n            getWorkspaceSymbols(query),\n          ]);\n          this.logger.info(\n            `listActiveSymbols: Found ${filteredDefault.length} filtered local symbols and ${workspaceSymbols.length} workspace symbols.`,\n          );\n\n          const mergedItems = mergeResults(\n            filteredDefault.map((s) => symbolToItem(s, filepath)),\n            workspaceSymbols,\n            query,\n            limit,\n          );\n          this.logger.info(`listActiveSymbols: Returning ${mergedItems.length} merged symbols.`);\n          return mergedItems;\n        } catch (error) {\n          this.logger.error(`listActiveSymbols: Failed - ${error}`);\n          return [];\n        }\n      },\n\n      getChanges: async (params: GetChangesParams): Promise<ChangeItem[]> => {\n        if (!this.gitProvider.isApiAvailable()) {\n          return [];\n        }\n\n        const maxChars = params.maxChars ?? undefined;\n        let remainingChars = maxChars;\n\n        const repositories = this.gitProvider.getRepositories();\n        if (!repositories) {\n          return [];\n        }\n\n        const getRepoChanges = async (\n          repos: Repository[],\n          staged: boolean,\n          charLimit?: number,\n        ): Promise<ChangeItem[]> => {\n          if (charLimit !== undefined && charLimit <= 0) {\n            return [];\n          }\n\n          const res: ChangeItem[] = [];\n          let currentCharCount = 0;\n\n          for (const repo of repos) {\n            const diffs = await this.gitProvider.getDiff(repo, staged);\n            if (!diffs) {\n              continue;\n            }\n\n            for (const diff of diffs) {\n              const diffChars = diff.length;\n\n              if (charLimit !== undefined && currentCharCount + diffChars > charLimit) {\n                break;\n              }\n\n              res.push({\n                content: diff,\n                staged: staged,\n              } as ChangeItem);\n\n              currentCharCount += diffChars;\n            }\n\n            if (charLimit !== undefined && currentCharCount >= charLimit) {\n              break;\n            }\n          }\n\n          return res;\n        };\n\n        const stagedChanges: ChangeItem[] = await getRepoChanges(repositories, true, remainingChars);\n\n        const stagedCharCount = stagedChanges.reduce((count, item) => count + item.content.length, 0);\n\n        remainingChars = maxChars !== undefined ? maxChars - stagedCharCount : undefined;\n\n        const unstagedChanges: ChangeItem[] = await getRepoChanges(repositories, false, remainingChars);\n\n        const res = [...stagedChanges, ...unstagedChanges];\n\n        this.logger.info(`Found ${res.length} changed files.`);\n\n        return res;\n      },\n      runShell: async (command: string) => {\n        const terminal = window.createTerminal("Tabby");\n        terminal.show();\n        terminal.sendText(command);\n      },\n    });\n  }\n\n  private checkStatusAndLoadContent() {\n    const statusInfo = this.lspClient.status.current;\n    const error = this.checkStatusInfo(statusInfo);\n    if (error) {\n      this.currentConfig = undefined;\n      this.loadErrorPage(error);\n      return;\n    }\n    const config = this.lspClient.agentConfig.current;\n    if (!config) {\n      this.currentConfig = undefined;\n      this.loadErrorPage("Cannot get the server configuration.");\n      return;\n    }\n    if (this.currentConfig?.endpoint !== config.server.endpoint || this.currentConfig?.token !== config.server.token) {\n      this.currentConfig = config.server;\n      this.loadChatPanel();\n    }\n  }\n\n  private getUriStylesheet() {\n    return (\n      this.webview?.asWebviewUri(Uri.joinPath(this.context.extensionUri, "assets", "chat-panel.css")).toString() ?? ""\n    );\n  }\n\n  private getUriAvatarTabby() {\n    return this.webview?.asWebviewUri(Uri.joinPath(this.context.extensionUri, "assets", "tabby.png")).toString() ?? "";\n  }\n\n  private loadChatPanel() {\n    const webview = this.webview;\n    if (!webview) {\n      return;\n    }\n    this.client = undefined;\n    this.emit("didChangedStatus", "loading");\n    this.reloadCount += 1;\n    webview.html = mainHtml\n      .replace(/{{RELOAD_COUNT}}/g, this.reloadCount.toString())\n      .replace(/{{SERVER_ENDPOINT}}/g, this.currentConfig?.endpoint ?? "")\n      .replace(/{{URI_STYLESHEET}}/g, this.getUriStylesheet())\n      .replace(/{{URI_AVATAR_TABBY}}/g, this.getUriAvatarTabby());\n\n    this.initChatPanel(webview);\n  }\n\n  private loadErrorPage(message: string) {\n    const webview = this.webview;\n    if (!webview) {\n      return;\n    }\n    this.client = undefined;\n    this.emit("didChangedStatus", "error");\n    this.reloadCount += 1;\n    webview.html = errorHtml\n      .replace(/{{RELOAD_COUNT}}/g, this.reloadCount.toString())\n      .replace(/{{URI_STYLESHEET}}/g, this.getUriStylesheet())\n      .replace(/{{URI_AVATAR_TABBY}}/g, this.getUriAvatarTabby())\n      .replace(/{{ERROR_MESSAGE}}/g, message);\n  }\n\n  // Returns undefined if no error, otherwise returns the error message\n  private checkStatusInfo(statusInfo: StatusInfo | undefined): string | undefined {\n    if (!statusInfo || statusInfo.status === "connecting") {\n      return \'Connecting to the Tabby server...<br/><span class="loader"></span>\';\n    }\n\n    if (statusInfo.status === "unauthorized") {\n      return "Your token is invalid.<br/><a href=\'command:tabby.updateToken\'><b>Update Token</b></a>";\n    }\n\n    if (statusInfo.status === "disconnected") {\n      return "Failed to connect to the Tabby server.<br/><a href=\'command:tabby.connectToServer\'><b>Connect To Server</b></a>";\n    }\n\n    const health = statusInfo.serverHealth;\n    if (!health) {\n      return "Cannot get the health status of the Tabby server.";\n    }\n\n    if (!health["webserver"] || !health["chat_model"]) {\n      return "You need to launch the server with the chat model enabled; for example, use `--chat-model Qwen2-1.5B-Instruct`.";\n    }\n\n    const MIN_VERSION = "0.27.0";\n\n    if (health["version"]) {\n      let version: semver.SemVer | undefined | null = undefined;\n      if (typeof health["version"] === "string") {\n        version = semver.coerce(health["version"]);\n      } else if (\n        typeof health["version"] === "object" &&\n        "git_describe" in health["version"] &&\n        typeof health["version"]["git_describe"] === "string"\n      ) {\n        version = semver.coerce(health["version"]["git_describe"]);\n      }\n      if (version && semver.lt(version, MIN_VERSION)) {\n        return `Tabby Chat requires Tabby server version ${MIN_VERSION} or later. Your server is running version ${version}.`;\n      }\n    }\n\n    return undefined;\n  }\n\n  private async applyInEditor(editor: TextEditor, content: string) {\n    const document = editor.document;\n    const selection = editor.selection;\n\n    // Determine the indentation for the content\n    // The calculation is based solely on the indentation of the first line\n    const lineText = document.lineAt(selection.start.line).text;\n    const match = lineText.match(/^(\\s*)/);\n    const indent = match ? match[0] : "";\n\n    // Determine the indentation for the content\'s first line\n    // Note:\n    // If using spaces, selection.start.character = 1 means 1 space\n    // If using tabs, selection.start.character = 1 means 1 tab\n    const indentUnit = indent[0];\n    const indentAmountForTheFirstLine = Math.max(indent.length - selection.start.character, 0);\n    const indentForTheFirstLine = indentUnit?.repeat(indentAmountForTheFirstLine) ?? "";\n    // Indent the content\n    const indentedContent = indentForTheFirstLine + content.replaceAll("\\n", "\\n" + indent);\n\n    // Apply into the editor\n    await editor.edit((editBuilder) => {\n      editBuilder.replace(selection, indentedContent);\n    });\n  }\n\n  private async smartApplyInEditor(editor: TextEditor, content: string) {\n    this.logger.info("Smart apply in editor started.");\n    this.logger.trace("Smart apply in editor with content:", { content });\n\n    window.withProgress(\n      {\n        location: ProgressLocation.Notification,\n        title: "Smart Apply in Progress",\n        cancellable: true,\n      },\n      async (progress, token) => {\n        progress.report({ increment: 0, message: "Applying smart edit..." });\n        try {\n          await this.lspClient.chat.provideSmartApplyEdit(\n            {\n              text: content,\n              location: {\n                uri: editor.document.uri.toString(),\n                range: {\n                  start: { line: editor.selection.start.line, character: editor.selection.start.character },\n                  end: { line: editor.selection.end.line, character: editor.selection.end.character },\n                },\n              },\n            },\n            token,\n          );\n        } catch (error) {\n          if (error instanceof Error) {\n            window.showErrorMessage(error.message);\n          } else {\n            window.showErrorMessage("An unknown error occurred");\n          }\n        }\n      },\n    );\n  }\n\n  private async notifyActiveEditorSelectionChange(editor: TextEditor | undefined) {\n    if (editor && editor.document.uri.scheme === "output") {\n      // do not update when the active editor is an output channel\n      return;\n    }\n\n    if (!editor || !isValidForSyncActiveEditorSelection(editor)) {\n      await this.client?.["0.8.0"].updateActiveSelection(null);\n      return;\n    }\n\n    const fileContext = await getEditorContext(editor, this.gitProvider);\n    await this.client?.["0.8.0"].updateActiveSelection(fileContext);\n  }\n\n  private debouncedNotifyActiveEditorSelectionChange = debounce(async (editor: TextEditor | undefined) => {\n    await this.notifyActiveEditorSelectionChange(editor);\n  }, 100);\n\n  private listFiles = wrapCancelableFunction(\n    listFiles,\n    (args) => args[2],\n    (args, token) => {\n      args[2] = token;\n      return args;\n    },\n  );\n\n  private getColorThemeString() {\n    switch (window.activeColorTheme.kind) {\n      case ColorThemeKind.Light:\n      case ColorThemeKind.HighContrastLight:\n        return "light";\n      case ColorThemeKind.Dark:\n      case ColorThemeKind.HighContrast:\n        return "dark";\n    }\n  }\n}\n',
            isTruncated: false,
          },
          toolName: "readFile",
          toolCallId: "toolu_vrtx_01Y6iRTCot1pay8QMnA4tyVy",
        },
      },
      {
        type: "step-start",
      },
      {
        text: "Let me also check if there are any other HTML files in the chat directory to understand the structure better:",
        type: "text",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/chat/html",
          },
          step: 3,
          state: "result",
          result: {
            files: [
              "clients/vscode/src/chat/html/error.html",
              "clients/vscode/src/chat/html/index.d.ts",
              "clients/vscode/src/chat/html/main.html",
            ],
            isTruncated: false,
          },
          toolName: "listFiles",
          toolCallId: "toolu_vrtx_01HvaeT2gHMb2ka4ps2txvBt",
        },
      },
      {
        type: "step-start",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            path: "clients/vscode/src/chat/html/main.html",
          },
          step: 4,
          state: "result",
          result: {
            content:
              '<!doctype html>\n<html lang="en">\n  <!--{{RELOAD_COUNT}}-->\n\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <link href="{{URI_STYLESHEET}}" rel="stylesheet" />\n    <link href="{{SERVER_ENDPOINT}}" rel="preconnect" />\n  </head>\n\n  <body>\n    <main class="static-content" id="loading-overlay">\n      <div class="avatar">\n        <img src="{{URI_AVATAR_TABBY}}" />\n        <p>Tabby</p>\n      </div>\n      <h4 class="title">Welcome to Tabby Chat!</h4>\n      <p>Just a moment while we get things ready...</p>\n      <span class="loader"></span>\n    </main>\n\n    <iframe id="chat" allow="clipboard-read; clipboard-write"></iframe>\n\n    <script defer>\n      const vscode = acquireVsCodeApi();\n      const chatIframe = document.getElementById("chat");\n      const loadingOverlay = document.getElementById("loading-overlay");\n\n      chatIframe.onload = () => {\n        vscode.postMessage({\n          action: "chatIframeLoaded",\n        });\n      };\n      chatIframe.src = encodeURI("{{SERVER_ENDPOINT}}/chat?client=vscode");\n\n      const syncStyle = () => {\n        const parentHtmlStyle = document.documentElement.getAttribute("style");\n        vscode.postMessage({\n          action: "syncStyle",\n          style: parentHtmlStyle,\n        });\n      };\n\n      const styleObserver = new MutationObserver(() => {\n        syncStyle();\n      });\n\n      styleObserver.observe(document.documentElement, {\n        attributes: true,\n        attributeFilter: ["style"],\n      });\n\n      const showChatIframe = () => {\n        syncStyle();\n        loadingOverlay.style.display = "none";\n        chatIframe.style.display = "block";\n      };\n\n      window.addEventListener("message", (event) => {\n        if (event.data) {\n          if (event.data.action === "dispatchKeyboardEvent") {\n            window.dispatchEvent(new KeyboardEvent(event.data.type, event.data.event));\n          } else if (event.data.action === "showChatPanel") {\n            showChatIframe();\n          } else if (event.data.action === "checkFocused") {\n            vscode.postMessage({\n              id: event.data.id,\n              action: "jsCallback",\n              args: [document.hasFocus()],\n            });\n          } else if (event.data.action === "postMessageToChatPanel") {\n            chatIframe.contentWindow.postMessage(event.data.message, "*");\n          } else {\n            vscode.postMessage(event.data);\n          }\n        }\n      });\n\n      window.addEventListener("focus", (e) => {\n        setTimeout(() => {\n          chatIframe.contentWindow.focus();\n        }, 0);\n      });\n    </script>\n  </body>\n</html>\n',
            isTruncated: false,
          },
          toolName: "readFile",
          toolCallId: "toolu_vrtx_01HGYCjG67Qi54y3EFfRuktW",
        },
      },
      {
        type: "step-start",
      },
      {
        type: "tool-invocation",
        toolInvocation: {
          args: {
            result:
              "The `clients/vscode/src/chat/html/error.html` file is a simple HTML template used to display error messages in the Tabby Chat feature of the VSCode extension. Here's a detailed explanation of its usage:\n\n## Purpose and Structure\n\nThe error.html file serves as a fallback UI template that is displayed when the Tabby Chat panel encounters an error or cannot properly connect to the Tabby server. It provides a user-friendly error message with the Tabby logo and branding.\n\nKey elements in the template:\n- A placeholder for the Tabby avatar image (`{{URI_AVATAR_TABBY}}`)\n- A title welcoming users to Tabby Chat\n- A placeholder for the specific error message (`{{ERROR_MESSAGE}}`)\n- A placeholder for reload count (`{{RELOAD_COUNT}}`) to force refreshes\n- A stylesheet reference (`{{URI_STYLESHEET}}`)\n\n## How It's Used in the Codebase\n\nThe error.html template is used by the `ChatWebview` class in `clients/vscode/src/chat/webview.ts`. Specifically:\n\n1. The template is imported at the top of the file:\n   ```typescript\n   import errorHtml from \"./html/error.html\";\n   ```\n\n2. It's used in the `loadErrorPage` method of the `ChatWebview` class:\n   ```typescript\n   private loadErrorPage(message: string) {\n     const webview = this.webview;\n     if (!webview) {\n       return;\n     }\n     this.client = undefined;\n     this.emit(\"didChangedStatus\", \"error\");\n     this.reloadCount += 1;\n     webview.html = errorHtml\n       .replace(/{{RELOAD_COUNT}}/g, this.reloadCount.toString())\n       .replace(/{{URI_STYLESHEET}}/g, this.getUriStylesheet())\n       .replace(/{{URI_AVATAR_TABBY}}/g, this.getUriAvatarTabby())\n       .replace(/{{ERROR_MESSAGE}}/g, message);\n   }\n   ```\n\n3. The `loadErrorPage` method is called in various scenarios when the chat panel cannot be properly initialized:\n   - When there's an issue connecting to the Tabby server\n   - When the user's authentication token is invalid\n   - When the server doesn't have the chat model enabled\n   - When the server version is incompatible with the client\n   - When the server health check fails\n\n## Error Scenarios\n\nThe error.html template is displayed in several specific scenarios:\n\n1. **Connection Issues**: When the extension can't connect to the Tabby server, showing a link to reconnect.\n2. **Authentication Problems**: When the user's token is invalid, showing a link to update the token.\n3. **Missing Chat Model**: When the server is running without a chat model enabled.\n4. **Version Incompatibility**: When the server version is older than the minimum required version.\n5. **Server Health Issues**: When the server health check indicates problems with required components.\n\n## Integration with Main UI\n\nThis error template is part of a dual-template system:\n- `main.html`: The primary template that loads the chat iframe when everything is working correctly\n- `error.html`: The fallback template shown when there are issues\n\nThe system switches between these templates based on the connection status and server health, providing appropriate feedback to the user about what might be wrong and how to fix it.\n\nThe error messages often include clickable links (using VSCode's command URIs like `command:tabby.reconnectToServer`) that allow users to take immediate action to resolve the issue, such as reconnecting to the server or updating their authentication token.",
          },
          step: 5,
          state: "call",
          toolName: "attemptCompletion",
          toolCallId: "toolu_vrtx_01VSKM9M3btH1bnLoMjDEF5N",
        },
      },
    ],
    content: "",
    createdAt: new Date("2025-05-18T05:29:27.555Z"),
    // revisionId: "875KSsJMdz8wyhtG",
  },
];

export const Messages1: Story = {
  args: {
    messages: messages1,
    user: {
      name: "User",
      image: "https://example.com/user-avatar.png",
    },
    isLoading: false,
    logo: logo,
    sendMessage: async () => null,
  },
  parameters: {
    backgrounds: { disable: true },
  },
};
